package lesson3_StackAndQueue;

// Используется для динамеческих массивов (ArrayList). Предела которого мы не знаем. Либо огромнейщая структура данных и мы не хотим работать с ним целиком. Для этого ищем димпазон.
/*
 Будем брать базовый элемент и каждый раз умножать его на 2. Базовым элементам берется первый элемент массива.
 B = 1*2*2*2
 Нулевой элемент массива надо проверить сразу, потому что у нему мы больше не вернемся.
 Сложность логарифмическая. Скорость такая же как и у бинарного.(разница незначительная).
 Как определить количество итераций. Берем расстояние между двумя элементами. Например между 2 во 2 степени и 2 в 3 степени (между 4 и 16. В этом промежутке уже работает обычный бинарный поиск.
 */

import lesson3_StackAndQueue.BinarySearch;

import java.util.Objects;

public class ExponentialSearch {

    public static int search(Integer[] arr, Integer num2Find) {

        if (Objects.equals(arr[0], num2Find)) {
            return 0;
        }

        int base = 1;
        int i = 0;

        // цикл работает пока базовое число находится в пределах багового массива и пока базовое число меньше или равно числу, которое мы ищем.
        // Диапазон поиска
        while (base < arr.length && arr[base] <= num2Find) {
            i++;

            if (Objects.equals(arr[base], num2Find)) {
                System.out.println("Число найдено(ЭП). Кол-во итераций " + i);
                return base;
            }
            // если не нашли, то увеличиваем диапазон в 2 раза
            base *= 2;
        }

        System.out.printf("ЭП закончен. Итерраций: %s, от %s, до %s%n", i,base / 2 + 1, Math.min(base - 1, arr.length - 1));


        // -1 здесь может вернуться, только если ее вернет бинарный поиск
//        return - 1;

        //start - это base / 2 потому что возвращает прошлый найденный элемент
        // end может быть один из двух, либо base - 1, либо arr.length(последный элемент массива). . Мы должны выбрать тот, что лежит в пределах массива, а если быть точнее должны выбрать тот, что меньше. Math.min
        return BinarySearch.search(arr, num2Find, base / 2 + 1, Math.min(base - 1, arr.length - 1));
    }
}
