Деревья - стркуктура, особенность которой, что под каждым узлом будут узлы, лежащие под ним.
Деревья бывают разные, мы рассмотрим классические (бинарные)
Самый первый узел - корень всего дерева (его родительский элемент равен null)
Нижележащие узлы называются дочерними.
Узлы связываются ребром (материального смысла не имеют, в графах наоборот)
Ребра всегда идет вниз
Дерево не может замыкаться (когда на один элемент ссылаются 2 элемента)
Также запрещено обращение на тот же самый узел (сам на себя.
Самый последний элемент называется ЛИСТ (его дочерние элементы равны Null)
У всех последних элементов есть дочерние элементы и равны они null. Фактически это представлено в виде полей последнего элемента, значение которых будет null.
Как найти конец дерева - последний элемент будет равне null.
Есть такое понятие как корень поддерева - абсолютно любой узел может выступать деревом внутри другого дерева.
!Файл в директории это лист.
Чтобы дерево стало бинарном: В бинарном дереве все элементы, находящиеся справа больше родительского элемента и соответственно наоборот.
Сбалансированное дерево - дерево, дочерние элементы которого не отличаются более чем на один уровень. Если дерево сбалансированно, то выдерживается бинарный поиск (потому что в таком дереве уже все готово для бинарного поиска).
В дереве Самый минимальный элемент лежит левее всех, максимальный правее всех.
Вариант плохого дерева - когда все элементы идут друг за другом O-O-O-O. В этом случае поиск, добавление и удаление O(n). Фактически говорим про список просто в более сложной обертке.

Node будет значение, правый элемент Node, левый элемент Node.


Метод compareTo() — сравнивает числовой объект, который вызывает метод, с аргументом. При работе с числами метод compareTo() в Java позволяет сравнить два числа одного типа, например, byte, long, integer и т. д.


В java активно используется красно - черное дерево. Это основа для таких структур (коллекций), таких как TreeSet и TreeHashMap.
В документации к них первой строчкой написанно - это реализация красно - черных деревьев.
Это в свою очередь приносит неудобства. Потому что красно - черные деревья могут в определенных ситуациях сводится к O(n).

Что такое красно - черное дерево и как оно будет балансировать наше дерево.
Самым первым элементом КЧ дерева является черный элемент (в качестве потомков может иметь как красные, так и черные элементы). Красный дочерний элемент не может содержать в качестве дочерних другие красные узлы. И самое главное - путь до любого листа в дереве должен занимать одинаковое количество черных узлов.
Если вдруг мы попытаемя добавить элемент, который будет ломать все наше дерево, то произойдет операция перестроения.
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
Такие коллекции очень эффективный если операций добавления у вас много и вы постоянно выполняете процедуру поиска.

Где еще есть деревья?
Самый лучший пример - базы данных.
Есть RB-tree - это самый простейший вид B-tree. Точнее B-дерево с основанием в 2 элемента. Есть еще AVL-деревья.


Обход дерева - это проход по каждому элементу дерева с целью его посещения, обработки с собственно посмотреть что же у нас там в этом узле есть.
Есть 2 разных глобальн способа: обход в ширину и обход в глубину.
Обход в ширину это прохождение по уровню, по каждому каждому уровню. Выводятся при помощи очередей, мы идем по каждому начиная с root (корневого элемента) и закидываем это а очередь.
Обход в глубину - ...

Есть 3 различных способа обхода дерева - прямой, центрированный и обратный.
Прямой:
m( current) {

c != null(? (выходим) // если current не существует то выходим

// если существует
sout (current) // сначала выводим current

// далее уходим в левую рекурсию
m (current.left)

// после левой идем в правую
m (current.right)
}

Центрированный обход: // сначала идем в левую рекурсию, выводим и идем в правую рекурсию
m (current) {
c!null (?)
m(current.left)
sout(current)
m(current.right)
}

Обратный обход: // сначала идем в левую рекурсию, затем идем в правую и только в конце выводим






