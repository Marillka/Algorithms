Два основных способа борьбы с колизией.
Первый, тот что используется в Java и тот что используется в Python.
На уроке рассмотрим тот, что используется в Python, а в домашке тот что в Java.

У нас идет какой нибудь массив. В ячейку номер 100 претендуют 3 слова.
Сначала туда кладется слово1. Как только сюда попадает слово2. В ячейке создается список (он будет хранить в себе все слова, которые претендует на ячейку 100 - этот называется  метод цепочек).
В java еще интереснее - как только количество сопостовлений достигает 8 штук, то оно все перестраивается в дерево (в домашке это перестроение делать не надо).

Получение уникального значения для любого нашего элемента называестся получение хеша этого самого элемента.
Hash для строк образуется примерно так - берется слово и расскладывается по разрядам. Получается hash - уникальная последовательность чисел из 9 разрядов в диапазоне Integer(- 2 000 000 000 до 2 000 000 000).
Для каждого типа данных будет свой подход по получению Hash.
Если вы создали свой собственный класс, то в этом случае вы должны сами подумать над тем как будет у вас получаться hash. Можете сделать это самостоятельно - например привязаться к индексу этого элемента, либо же сделать так что Hash будет получаться только исключительно например из названия вашего класса. Например у класса кота есть возраст, цвет, вес, и можно привязаться ко всем полям и на основе трех полей получать Hash.

Общая концепция такова.
Одинаковые поля, пусть даже и разных экземпляров должны отдавать один и тот же Hash. Это все на чем держиться вся работа Hasha. Получение хеша это статическая формула, которая не меняется со временем.

Если hash совпадает - то это не факт, что 2 экземпляра идентичны.

Дальше создается массив и в этом массиве будет позиция элемента, которого мы хотим туда подставить. Получение реального индекса в массиве исоходя из хеша элемента которого мы хотим туда добавить называется хеш-функция.

Entry хранит в себе пару ключ-значение (key-value).
По умолчанию в Java длинна массива 16.

Открытая адресация это возможность получения индекса путем сдвига элемента на позицию дальше.
Имеет преимущество в плане простоты, главный минус - в самом худшем случае O(n).
Чтобы открытая адресация работала лучше и эффективнее принято увеличивать указанный вами размер в 2 раза. То есть хотите хранить 10 элементов - массив должен быть на 20 элементов. 30 - 60. Это необходимо для того чтобы появлялись вот эти свободные ячейки.

 Линейное пробирование : x+1, x+2, x+3... x+n. Просто прохождение по соседним ячейкам. Вперед вперед вперед.
 Квадратичное пробирование: x+1, x+4, x+9 ...x+n
 x+1^1, x+2^2, x+3^2, x+n^2. Нужно каждый раз брать следующее число и возводить его в квадрат. Это даст преимущество в том, что прыжки будут совершаться с некоторым расстоянием друг от друга и чем дальше - тем длиньше будут эти разрывы. И это должно помочь чтобы пробелы в массиве были чуть меньше.
 Есть еще способ - двойное хеширование. Это способ, которые добавляет на еще одно хеширование на этапе этого самого пробития.

 Сложность добавления:
 в лучшем O(1)
 в хушем O(n) (при открытой адресации). O(n) когда до 8 элементов (при методе цепочек. Либо же O(log n) когда больше или равно 8 элементам. Чем больше элементов тем сложность лучше, из за того что будет переформирование из списка в двоичное дерево (красно - черное, т.е. сбалансированное).

В случае добавления, извлечения будет все иметь в лучшем случае O(1).

Единственно НО с хеш таблицами, которое надо помнить, что пересоздание ваший хеш таблицы будет означать полное передобавление всех элементов, что есть у вас - O(n) * O(log n).
Почемк такое происходит. Представьте себе у вас есть не особо большой массив. Вы в него добавляете, добавляете, и в какой то момент понимаете что ваш массив слишко м плотный и вам нужно его пересоздать (или у вас место закончилось). В Java в HashMap есть переменная loadAverage, которая показывает забитость массива. Как только переменная становится равной 0.75 массив пересоздается. При этом нужно все элементы из старого массива передобавлять в новый массив, потому что хеш функция зависит от размера массива.
 Исходя из этого лучше создавать hash таблицы с запасом.

 Доп. материал от преподавателя:
 Что такое кучи и почему они так важны.
 Куча это такая древовидная структура, которая способна сохраняться в массиве.
 У кучи только одно правило - все что лежит ниже элемента в его поддереве должно быть меньше самого этого элемента.
 Как это все потом преобразуется в массив?
 Берется обход в ширину и переводится в массив. Добавление в кучу происходит всегда поочередно (пока все элементы уровня не заполнятся - на другой уровень не перейдем).
 Какова сложность кучи?
 Построение O(n)
 Добавление O(log n)
 Извлечение O(log n)
 Исходя из этого можно пользоваться 2 вещами:
 1) На самом верху дерева (самый первый элемент) - будет самое большое значение. Если удалить этот самый первый элемент, то перестроение кучи займет O(log n).

 Как строиться куча и как все это связать с сортировкой?
 Строиться куча от конца. Есть 2 формулы. Как найти обслолютно любой родитель абсолютно любого элемента и как найти любой дочерний элемент любого элемента.
 ..
