Рекурсия - это необходимость повторения какого либо действия путем вызова метода повторно.

Любой цикл можно заменить рекурсией.

Ее плюс в что когда мы перезапкскаем рекурсию, мы имеем возможность не только какой то код выполнить с измененными цифрами, а мы можем подать совершенно другие входные данные и работать с ними.

Премищество в том что каждый цикл может стать рекурский, но не каждая рекурсия может стать циклом.


Вывод: если рекурсию можно заменить циклом, то обязательно нужно это делать, потому что цикл всегда по памяти занимает O(1), в случае с рекурсией O(n). Даже пузырьковая сортировка лучше чем через рекурсию.

Домашка:
1) возведение в степень. Не забывайте что возведение в степень может быть как положительным, так и отрицательным. Дополнительно: возведение в нецелую степень (0.5), вы должны сначала помнить что возведение в 0.5 это извлечение из квадратного корня.

2) Задача о рюкзаке. Та же самая задача с анограммами с перебором всех вариантов, и вам нужно просто чуть чуть совсем изменить.
Представьте что вы вор и вы залезаете в квартуру. И в этой квартире вы видите множество различных вещей (ноутбук - 40 000 (4 кг), часы 5000 (1 кг), гиря - 100 (5 кг), гитара - 37000 (3 кг), смартфон - 10000 (2кг). Задача в том, чтобы собрать самый дорогой сет, который можно унести (объем рюкзака 5 кг). И как это решать? При помощи рекурсии конечно. У вас есть 5 предметов, знаете их, видите. И считаете сначала общюю массу всех предметов = 15 кг. Это явно больше чем можно унести. Далее пробегаемся по всем этим предметам и начинаем извлекать из них (исключать из этого состава) по одному предмету. И получается что у нас будет дальше ноутбук, часы, гитара, смартфон (гирю исключили), и масса стала 10 кг. Этого все равно недостаточно, поэтому исключаем еще по несколько вариантов (уберем ноутбук, и получится часы, гитара, смартфон = 6 кг, исключаем часы и получается гитара и смартфон = 5кг и нас это устраивает, считаем общую стоимость и запоминаем) И считаете общую стоимость всех предметов.
Кароче с самого начала вы исключаете по одному предмету до тех пор пока не будем попадать по весу. После считаем и запоминаем состав, массу, цену. Далее сравниваем и все.
Отличие от аннограмы в том что мы сдвигали и не изменяли состав. А в случае с рюкзаком будем исключать буквы по одной. И добавиться метод по сохранинию всего этого и проверки.

Быстрая сортировка:
Мы выбираем число в массиве, неважно каким оно будет (первым, последним, в середине). После чего создаются 3 списка, и в эти 3 списка мы кладем числа, которые меньше, равны и больше основания. Дальше проходимся по каждому.
Быстрая сортировка не идеальная. Главный минус, если массив уже отсортирован то мы просто по каждому элементу будем поочередно проходиться проходиться и проходиться.
Основвание выбирается из центра для избежания ситуации, когда массив уже отсортирован, и тогда будет возникать проблема только разьве что с обратно отсортированным массивом. Такой небольшой костыль для улучшения сортировки.

Алгоритм блоха:
Быстрая сортировка с 2 основаниями. Именно она является базовой в примитивных типах в Java.

СОРТИРОВКА СЛИЯНИЕМ.
Начинается с того, что есть какой то массив.
Если быстрой сортировкой все делили на пополам, то здесь наоборот. Сортировка слиянием сначала будет работать по одному элементу и будет их каждый раз сливать в один массив.
Берем два элемента и начинаем собирать их в один. Смотрим 5 и 2, что больше.
5 2 4 1 3 7 5 9 11 0 1              11 элементов    11 < 2^4 => 4 шага
[2 5] [1 4] [3 7] [5 9] [0 11] [1]  1   n
[1 2 4 5] [3 5 7 9] [0 1 11]        2   n
[1 2 3 4 5 5 7 9] [0 1 11]          3   n
[0 1 1 2 3 4 5 5 7 9 11]            4   n
Используется по умолчанию для сортировки ссылочных типов данных в Java.

Чтобы проверить отсортирован массив или нет есть только один способ - пробежаться по нему.